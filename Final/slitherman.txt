;;;Accept board configuration and initialize counters
(defun create-board (filename)
  (let ((infile (open filename)))
  (setq board (read infile))
  (setq pboard board)
  (setq cboard (mapcar (lambda (x) (cond ((listp x) (mapcar (lambda (y) (cond ((constantp y) 0)
                                                                              (t y) )) x ))
                                         (t nil) )) board ))
  (close infile) ) )
                                                      
(defun print-row (row r c)    
  (cond ((null row) (cond ((member (list r (1- c) 'R) list-of-moves :test #'equal) (princ "|"))
                          (t (princ " ")) ))
        (t (cond ((member (list r c 'L) list-of-moves :test #'equal) (princ "|"))
                 ((member (list r (1- c) 'R) list-of-moves :test #'equal) (princ "|"))
                 (t (princ " ")) )
           (cond ((equal '- (car row)) (princ " "))
                 (t (princ (car row))) )
           (print-row (cdr row) r (1+ c)) ) ) )
            
(defun print-board (pboard num-of-rows num-of-cols list-of-moves mypos)
  (cond ((null pboard) (princ "  +")
                       (setq i 0)
                       (loop
                         (cond ((member (list (1- num-of-rows) i 'B) list-of-moves :test #'equal) (princ "-")
                                                                                                  (princ "+"))
                               (t (princ " ")
                                  (princ "+")) )
                         (setq i (1+ i))
                         (when (equal i num-of-cols)
                           (terpri)
                           (return t) ) ) )
        (t (princ "  +")
           (setq i 0)
           (loop
             (cond ((member (list mypos i 'T) list-of-moves :test #'equal) (princ "-")
                                                                           (princ "+"))
                   ((member (list (1- mypos) i 'B) list-of-moves :test #'equal) (princ "-")
                                                                                (princ "+"))
                   (t (princ " ")
                      (princ "+")) )
             (setq i (1+ i))
             (when (equal i num-of-cols)
               (terpri)
               (return t) ) )
           (princ (1+ mypos))
           (princ " ")          
           (print-row (car pboard) mypos 0)
           (terpri)
           (print-board (cdr pboard) num-of-rows num-of-cols list-of-moves (1+ mypos))
           (terpri) ) ) )
         
;;;Return edge of the adjacent square that gets affected due to current move
(defun get-duplicate-move (move)
  (setq r (nth 0 move))
  (setq c (nth 1 move))
  (cond ((equal c 0) (cond ((equal (nth 2 move) 'R) (list r (1+ c) 'L))
                           ((and (equal r 0) (equal (nth 2 move) 'B)) (list (1+ r) c 'T))
                           ((and (equal r (1- num-of-rows)) (equal (nth 2 move) 'T)) (list (1- r) c 'B))
                           (t (cond ((and (< r (1- num-of-rows)) (equal (nth 2 move) 'B)) (list (1+ r) c 'T))
                                    ((and (> r 0) (equal (nth 2 move) 'T)) (list (1- r) c 'B))
                                    (t nil) )) ))
        ((equal c (1- num-of-cols)) (cond ((equal (nth 2 move) 'L) (list r (1- c) 'R))
                                          ((and (equal r 0) (equal (nth 2 move) 'B)) (list (1+ r) c 'T))
                                          ((and (equal r (1- num-of-rows)) (equal (nth 2 move) 'T)) (list (1- r) c 'B))
                                          (t (cond ((and (< r (1- num-of-rows)) (equal (nth 2 move) 'B)) (list (1+ r) c 'T))
                                                   ((and (> r 0) (equal (nth 2 move) 'T)) (list (1- r) c 'B))
                                                   (t nil) )) ))
        (t (cond ((equal (nth 2 move) 'R) (list r (1+ c) 'L))
                 ((equal (nth 2 move) 'L) (list r (1- c) 'R))
                 ((and (< r (1- num-of-rows)) (equal (nth 2 move) 'B)) (list (1+ r) c 'T))
                 ((and (> r 0) (equal (nth 2 move) 'T)) (list (1- r) c 'B))
                 (t nil) )) ) )

;;;Increment the counter for a particular square
(defun update-square (r c cboard type)
  (cond ((equal type 1) (cond ((numberp (nth c (nth r cboard))) (setf (nth c (nth r cboard)) (1+ (nth c (nth r cboard)))))
                              (t nil) ))
        (t (cond ((numberp (nth c (nth r cboard))) (setf (nth c (nth r cboard)) (1- (nth c (nth r cboard)))))
                 (t nil) )) ) )
        
;;;Update the counter-board (cboard) based on the move
(defun update-score (move num-of-rows num-of-cols type)
  (setq r (nth 0 move))
  (setq c (nth 1 move))
  (update-square r c cboard type)
  (setq dmove (get-duplicate-move move))
  (cond ((null dmove) nil)
        (t (setq r (nth 0 dmove))
           (setq c (nth 1 dmove))
           (update-square r c cboard type)) ) )
            
(defun is-row-valid (move num-of-rows)
  (cond ((and (< (nth 0 move) num-of-rows)
              (>= (nth 0 move) 0) ) t )
        (t nil) ) )
        
(defun is-column-valid (move num-of-rows)
  (cond ((and (< (nth 1 move) num-of-cols)
              (>= (nth 1 move) 0) ) t )
        (t nil) ) )
        
(defun is-edge-valid (move)
  (cond ((or (equal (nth 2 move) 'T)
             (equal (nth 2 move) 'B)
             (equal (nth 2 move) 'R)
             (equal (nth 2 move) 'L) ) t )
        (t nil) ) )
        
(defun undo-move (num-of-rows num-of-cols list-of-moves move)
  (update-score move num-of-rows num-of-cols 0)
  (set 'list-of-moves (remove move list-of-moves :test #'equal)) )    

(defun accept-move ()
  (write-line " ")
  (princ "Make a move : ")
  (set 'move (list (read) (read) (read)))
  (cond ((not (and (numberp (nth 0 move))
                   (numberp (nth 1 move)) )) (princ "Invalid input!")
                                             (terpri) )
        (t (setq move (mapcar (lambda (x) (cond ((equal T x) x) ((symbolp x) x) ((constantp x) (1- x)))) move))
           (cond ((not (is-row-valid move num-of-rows)) (princ "Please enter a valid row number")
                                                        (terpri)
                                                        (accept-move) )
                 ((not (is-column-valid move num-of-cols)) (princ "Please enter a valid column number")
                                                           (terpri)
                                                           (accept-move) )
                 ((not (is-edge-valid move)) (princ "Please enter a valid value for edge. Valid values for edge are T, B, R or L") 
                                             (terpri)
                                             (accept-move) )        
                 (t (cond ((member move list-of-moves :test #'equal) (undo-move num-of-rows num-of-cols list-of-moves move))
                          ((member (get-duplicate-move move) list-of-moves :test #'equal) (undo-move num-of-rows num-of-cols list-of-moves (get-duplicate-move move)))
                          (t (update-score move num-of-rows num-of-cols 1)
                             (push move list-of-moves) ) )) ) ) )
  (write-line " ") )
    
;;;Check if there is any T shape (crossing or branch)
(defun is-crossing (moves num-of-rows num-of-cols)
  (setq crossing 0)
  (loop for r from 0 to (- num-of-rows 2) do
    (loop for c from 0 to (- num-of-cols 2) do
      (cond ((or (and (or (member (list r c 'B) moves :test #'equal)
                          (member (list (1+ r) c 'T) moves :test #'equal) )
                      (or (member (list r (1+ c) 'B) moves :test #'equal)
                          (member (list (1+ r) (1+ c) 'T) moves :test #'equal) )
                      (or (member (list r c 'R) moves :test #'equal)
                          (member (list r (1+ c) 'L) moves :test #'equal) ) )
                 (and (or (member (list r c 'T) moves :test #'equal)
                          (member (list (1- r) c 'B) moves :test #'equal) )
                      (or (member (list r (1+ c) 'T) moves :test #'equal)
                          (member (list (1- r) (1+ c) 'B) moves :test #'equal) )
                      (or (member (list r c 'R) moves :test #'equal)
                          (member (list r (1+ c) 'L) moves :test #'equal) ) )
                 (and (or (member (list r c 'L) moves :test #'equal)
                          (member (list r (1- c) 'R) moves :test #'equal) )
                      (or (member (list (1+ r) c 'L) moves :test #'equal)
                          (member (list (1+ r) (1- c) 'R) moves :test #'equal) )
                      (or (member (list r c 'B) moves :test #'equal)
                          (member (list (1+ r) c 'T) moves :test #'equal) ) )
                 (and (or (member (list r c 'B) moves :test #'equal)
                          (member (list (1+ r) c 'T) moves :test #'equal) )
                      (or (member (list r c 'R) moves :test #'equal)
                          (member (list r (1+ c) 'L) moves :test #'equal) )
                      (or (member (list (1+ r) c 'R) moves :test #'equal)
                          (member (list (1+ r) (1+ c) 'L) moves :test #'equal) ) ) ) (setq crossing (1+ crossing)) )
                 (t nil) ) ) )
  (cond ((> crossing 0) t)
        (t nil) ) )
        
;;;Set edge in edge counter
(defun update-edge-count (i edge-type direction)
  (cond ((equal direction 0) (setf (nth i edge-type)
                             (1- (nth i edge-type)) ) )
        (t (setf (nth i edge-type) (1+ (nth i edge-type))) ) ) )
    
;;;Check if loop is closed
(defun is-loop (moves)
  (setq v (make-list num-of-rows :initial-element 0))
  (setq h (make-list num-of-cols :initial-element 0))
  (loop for move in moves do
    (cond ((or (equal (nth 2 move) 'L)
               (equal (nth 2 move) 'R) ) (update-edge-count (nth 0 move) v 1) )
          (t (update-edge-count (nth 1 move) h 1)) ) ) 
    (cond ((or (some #'(lambda (n) (equal (mod n 2) 1)) h)
               (some #'(lambda (n) (equal (mod n 2) 1)) v) ) nil )
          (t t) ) )
          
;;;Check if user won
(defun win-detected (board cboard moves num-of-rows num-of-cols)
  (cond ((and (equal cboard board)
              (is-loop moves)
              (not (is-crossing moves num-of-rows num-of-cols)) ) t )
        (t nil) ) )
          
;;;main routine
(defun slitherman ()
  (princ "Enter full path to the file containing description of the board:")
  (setq infile (read-line))
  (terpri)
    
  (create-board infile)
        
  ;;initialize list of moves and number of rows and columns
  (setq list-of-moves '())
  (setq num-of-rows (list-length board))
  (setq num-of-cols (list-length (car board)))
        
  (loop
    (princ "   ")
    (loop for i from 1 to num-of-cols do ;print column numbers
      (princ i)
      (princ " ") )
    (terpri)
    (print-board pboard num-of-rows num-of-cols list-of-moves 0)
    (accept-move)
    (when (win-detected board cboard list-of-moves num-of-rows num-of-cols)
      (princ "   ")
      (loop for i from 1 to num-of-cols do ;print column numbers
        (princ i)
        (princ " ") )
      (terpri)
      (print-board pboard num-of-rows num-of-cols list-of-moves 0)
      (princ "YOU WIN!")
	  (princ "Following is the list of moves you made: ")
	  (terpri)
	  (princ list-of-moves)
	  (terpri)
      (return t) ) ) )
        
