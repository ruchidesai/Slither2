;;;Accept the file containing the board description from the user and initialize counter boards
(defun create-board (filename)
  (let ((infile (open filename)))
    (setq board (read infile))
    (setq pboard board)
    (setq cboard (mapcar (lambda (xx) (cond ((listp xx) (mapcar (lambda (yy) (cond ((constantp yy) 0)
                                                                                   (t yy) )) xx ))
                                            (t nil) )) board ))
	(setq num-of-rows (list-length board))
    (setq num-of-cols (list-length (car board)))
	(setq final-moves nil)
    (close infile) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;Mark initial definite moves
(defun finalize-move (tmove)
  (cond ((not (member tmove final-moves :test #'equal)) (make-move (nth 0 tmove) (nth 1 tmove) (nth 2 tmove))
                                                        (push (list (nth 0 tmove) (nth 1 tmove) (nth 2 tmove)) final-moves-fixed) )
        (t nil) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;If there are adjacent three and zero then finalize the edges around three except for the one it shares with zero
;;If there are adjacent threes then finalize the edge shared by them
;;If there is a three in a corner then finalize the moves forming that corner
;;If there is a one in a corner then invalidate the edges forming that corner
;;If there is a two in a corner then finalize certain edges
(defun place-initial-edges ()
  (loop for iii from 0 to (1- num-of-rows) do
    (loop for jjj from 0 to (1- num-of-cols) do
      (cond ((equal 3 (nth jjj (nth iii board))) (cond ((equal iii 0) (cond ((equal jjj 0) (finalize-move (list iii jjj 'T))
                                                                                           (finalize-move (list iii jjj 'L))
                                                                                           (cond ((and (> num-of-rows 2)
                                                                                                       (> num-of-cols 2)
                                                                                                       (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                                                 (t nil) )
                                                                                           (cond ((and (> num-of-rows 2)
                                                                                                       (> num-of-cols 2)
                                                                                                       (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                                                 (t nil) ) )
                                                                      ((equal jjj (1- num-of-cols)) (finalize-move (list iii jjj 'T))
                                                                                                    (finalize-move (list iii jjj 'R))
                                                                                                    (cond ((and (> num-of-rows 2)
                                                                                                                (> num-of-cols 2)
                                                                                                                (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                                                          (t nil) ) )
                                                                      (t (cond ((equal 0 (nth jjj (nth (1+ iii) board))) (finalize-move (list (1+ iii) (1- jjj) 'T))
                                                                                                                         (finalize-move (list iii jjj 'L))
                                                                                                                         (finalize-move (list iii jjj 'T))
                                                                                                                         (finalize-move (list iii (1+ jjj) 'L))
                                                                                                                         (finalize-move (list (1+ iii) (1+ jjj) 'T)) )
                                                                               ((and (> num-of-rows 2)
                                                                                      (> num-of-cols 2)
                                                                                      (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                               (t nil) )
                                                                         (cond ((equal 0 (nth (1- jjj) (nth (1+ iii) board))) (finalize-move (list iii jjj 'L))
                                                                                                                              (finalize-move (list (1+ iii) jjj 'T)) )
                                                                               (t nil) )
                                                                         (cond ((equal 0 (nth (1- jjj) (nth (1+ iii) board))) (finalize-move (list iii (1+ jjj) 'L))
                                                                                                                              (finalize-move (list (1+ iii) jjj 'T)) )
                                                                               (t nil) )
                                                                         (cond ((and (> num-of-rows 2)
                                                                                     (> num-of-cols 2)
                                                                                     (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                               (t nil) ) ) ))
                                                   ((equal iii (1- num-of-rows)) (cond ((equal jjj 0) (finalize-move (list iii jjj 'L))
                                                                                                      (finalize-move (list iii jjj 'B))
                                                                                                      (cond ((and (> num-of-rows 2)
                                                                                                                  (> num-of-cols 2)
                                                                                                                  (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                                                            (t nil) ) )
                                                                                       ((equal jjj (1- num-of-cols)) (finalize-move (list iii jjj 'R))
                                                                                                                     (finalize-move (list iii jjj 'B)) )
                                                                                       (t (cond ((equal 0 (nth jjj (nth (1- iii) board))) (finalize-move (list iii (1- jjj) 'T))
                                                                                                                                    (finalize-move (list iii jjj 'L))
                                                                                                                                    (finalize-move (list iii jjj 'B))
                                                                                                                                    (finalize-move (list iii (1+ jjj) 'L))
                                                                                                                                    (finalize-move (list iii (1+ jjj) 'T)) )
                                                                                                (t nil) )
                                                                                          (cond ((equal 0 (nth (1- jjj) (nth (1- iii) board))) (finalize-move (list iii jjj 'L))
                                                                                                                                               (finalize-move (list iii jjj 'T)) )
                                                                                                (t nil) )
                                                                                          (cond ((equal 0 (nth (1+ jjj) (nth (1- iii) board))) (finalize-move (list (1- iii) (1+ jjj) 'L))
                                                                                                                                               (finalize-move (list iii (1+ jjj) 'T)) )
                                                                                                (t nil) )
                                                                                          (cond ((and (> num-of-rows 2)
                                                                                                      (> num-of-cols 2)
                                                                                                      (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                                                (t nil) ) ) ))
                                                   (t (cond ((equal jjj 0) (cond ((equal 0 (nth (1+ jjj) (nth iii board))) (finalize-move (list (1- iii) (1+ jjj) 'L))
                                                                                                                           (finalize-move (list iii jjj 'T))
                                                                                                                           (finalize-move (list iii jjj 'L))
                                                                                                                           (finalize-move (list (1+ iii) jjj 'T))
                                                                                                                           (finalize-move (list (1+ iii) (1+ jjj) 'L)) )
                                                                                 ((and (> num-of-rows 2)
                                                                                       (> num-of-cols 2)
                                                                                       (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                                 (t nil) )
                                                                         (cond ((equal 0 (nth (1+ jjj) (nth (1- iii) board))) (finalize-move (list iii jjj 'T))
                                                                                                                              (finalize-move (list iii (1+ jjj) 'L)) )
                                                                               (t nil) )
                                                                         (cond ((equal 0 (nth (1+ jjj) (nth (1+ iii) board))) (finalize-move (list (1+ iii) jjj 'T))
                                                                                                                              (finalize-move (list iii (1+ jjj) 'L)) )
                                                                               (t nil) )
                                                                         (cond ((and (> num-of-rows 2)
                                                                                     (> num-of-cols 2)
                                                                                     (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                               (t nil) ) )
                                                            ((equal jjj (1- num-of-cols)) (cond ((equal 0 (nth (1- jjj) (nth iii board))) (finalize-move (list (1- iii) jjj 'L))
                                                                                                                                          (finalize-move (list iii jjj 'T))
                                                                                                                                          (finalize-move (list iii jjj 'R))
                                                                                                                                          (finalize-move (list (1+ iii) jjj 'T))
                                                                                                                                          (finalize-move (list (1+ iii) jjj 'L)) )
                                                                                                (t nil) )
                                                                                          (cond ((equal 0 (nth (1- jjj) (nth (1- iii) board))) (finalize-move (list iii jjj 'T))
                                                                                                                                               (finalize-move (list iii jjj 'L)) )
                                                                                                (t nil) )
                                                                                          (cond ((equal 0 (nth (1- jjj) (nth (1+ iii) board))) (finalize-move (list iii jjj 'L))
                                                                                                                                               (finalize-move (list (1+ iii) jjj 'T)) )
                                                                                                (t nil) )
                                                                                        (cond ((and (> num-of-rows 2)
                                                                                                    (> num-of-cols 2)
                                                                                                    (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                                              (t nil) ) )
                                                            (t (cond ((equal 0 (nth (1- jjj) (nth (1- iii) board))) (finalize-move (list iii jjj 'L))
                                                                                                                    (finalize-move (list iii jjj 'T)) )
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth jjj (nth (1- iii) board))) (finalize-move (list iii (1- jjj) 'T))
                                                                                                               (finalize-move (list iii jjj 'L))
                                                                                                               (finalize-move (list (1+ iii) jjj 'T))
                                                                                                               (finalize-move (list iii (1+ jjj) 'L))
                                                                                                               (finalize-move (list iii (1+ jjj) 'T)) )
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth (1+ jjj) (nth (1- iii) board))) (finalize-move (list iii jjj 'T))
                                                                                                                    (finalize-move (list iii (1+ jjj) 'L)) )
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth (1+ jjj) (nth iii board))) (finalize-move (list (1- iii) (1+ jjj) 'L))
                                                                                                               (finalize-move (list iii jjj 'T))
                                                                                                               (finalize-move (list iii jjj 'L))
                                                                                                               (finalize-move (list (1+ iii) jjj 'T))
                                                                                                               (finalize-move (list (1+ iii) (1+ jjj) 'L)) )
                                                                     ((and (> num-of-rows 2)
                                                                           (> num-of-cols 2)
                                                                           (equal 3 (nth (1+ jjj) (nth iii board))) ) (finalize-move (list iii (1+ jjj) 'L)))
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth (1+ jjj) (nth (1+ iii) board))) (finalize-move (list iii (1+ jjj) 'L))
                                                                                                                    (finalize-move (list (1+ iii) jjj 'T)) )
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth jjj (nth (1+ iii) board))) (finalize-move (list (1+ iii) (1- jjj) 'T))
                                                                                                               (finalize-move (list iii jjj 'L))
                                                                                                               (finalize-move (list iii jjj 'T))
                                                                                                               (finalize-move (list iii (1+ jjj) 'L))
                                                                                                               (finalize-move (list (1+ iii) (1+ jjj) 'T)) )
                                                                     ((and (> num-of-rows 2)
                                                                           (> num-of-cols 2)
                                                                           (equal 3 (nth jjj (nth (1+ iii) board))) ) (finalize-move (list (1+ iii) jjj 'T)))
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth (1- jjj) (nth (1+ iii) board))) (finalize-move (list iii jjj 'L))
                                                                                                                    (finalize-move (list (1+ iii) jjj 'T)) )
                                                                     (t nil) )
                                                               (cond ((equal 0 (nth (1- jjj) (nth iii board))) (finalize-move (list (1- iii) jjj 'L))
                                                                                                               (finalize-move (list iii jjj 'T))
                                                                                                               (finalize-move (list iii (1+ jjj) 'L))
                                                                                                               (finalize-move (list (1+ iii) jjj 'T))
                                                                                                               (finalize-move (list (1+ iii) jjj 'L)) )
                                                                     (t nil) ) ) )) ))
            ((equal 1 (nth jjj (nth iii board))) (cond ((and (equal iii 0)
                                                             (equal jjj 0) ) (setf (nth 2 (find (list iii jjj 'T) list-of-moves :key #'car :test #'equal)) 'B)(princ "one")(terpri)
                                                                             (setf (nth 2 (find (list iii jjj 'L) list-of-moves :key #'car :test #'equal)) 'B) )
                                                       ((and (equal iii 0)
                                                             (equal jjj (1- num-of-cols)) ) (setf (nth 2 (find (list iii jjj 'T) list-of-moves :key #'car :test #'equal)) 'B)
                                                                                            (setf (nth 2 (find (list iii jjj 'R) list-of-moves :key #'car :test #'equal)) 'B) )
                                                       ((and (equal iii (1- num-of-rows))
                                                             (equal jjj 0) ) (setf (nth 2 (find (list iii jjj 'L) list-of-moves :key #'car :test #'equal)) 'B)
                                                                             (setf (nth 2 (find (list iii jjj 'B) list-of-moves :key #'car :test #'equal)) 'B) )
                                                       ((and (equal iii (1- num-of-rows))
                                                             (equal jjj (1- num-of-cols)) ) (setf (nth 2 (find (list iii jjj 'R) list-of-moves :key #'car :test #'equal)) 'B)
                                                                                            (setf (nth 2 (find (list iii jjj 'B) list-of-moves :key #'car :test #'equal)) 'B) )
                                                       (t nil) ))
            ((equal 2 (nth jjj (nth iii board))) (cond ((and (equal iii 0)
                                                             (equal jjj 0) ) (finalize-move (list iii (1+ jjj) 'T))
                                                                             (finalize-move (list (1+ iii) jjj 'L)) )
                                                       ((and (equal iii 0)
                                                             (equal jjj (1- num-of-cols)) ) (finalize-move (list iii (1- jjj) 'T))
                                                                                            (finalize-move (list (1+ iii) jjj 'R)) )
                                                       ((and (equal iii (1- num-of-rows))
                                                             (equal jjj 0) ) (finalize-move (list (1- iii) jjj 'L))
                                                                             (finalize-move (list iii (1+ jjj) 'B)) )
                                                       ((and (equal iii (1- num-of-rows))
                                                             (equal jjj (1- num-of-cols)) ) (finalize-move (list (1- iii) jjj 'R))
                                                                                            (finalize-move (list iii (1- jjj) 'B)) )
                                                       (t nil) ))
            (t nil) ) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Initialize the lists of moves
;;;Invalidate the edges around a zero
(defun initialize-for-dfs ()
  (setq list-of-moves nil)  
  (setq final-moves-fixed nil)  
  (loop for ii from 0 to (1- num-of-rows) do
    (loop for jj from 0 to (1- num-of-cols) do
      (cond ((> ii 0) (cond ((equal 0 (nth jj (nth (1- ii) board))) (push (list (list ii jj 'T) nil 'B) list-of-moves))
                            (t nil) ))
            (t nil) )
      (cond ((> jj 0) (cond ((equal 0 (nth (1- jj) (nth ii board))) (push (list (list ii jj 'L) nil 'B) list-of-moves))
                            (t nil) ))
            (t nil) )
      (cond ((equal 0 (nth jj (nth ii board))) (cond ((not (member (list ii jj 'L) list-of-moves :key #'car :test #'equal)) (push (list (list ii jj 'L) nil 'B) list-of-moves))
                                                     (t nil) )
                                               (cond ((not (member (list ii jj 'T) list-of-moves :key #'car :test #'equal)) (push (list (list ii jj 'T) nil 'B) list-of-moves))
                                                     (t nil) ) )
            (t (cond ((not (member (list ii jj 'L) list-of-moves :key #'car :test #'equal)) (push (list (list ii jj 'L) nil 'W) list-of-moves))
                     (t nil) )
               (cond ((not (member (list ii jj 'T) list-of-moves :key #'car :test #'equal)) (push (list (list ii jj 'T) nil 'W) list-of-moves))
                     (t nil) ) ) )
      (cond ((equal jj (1- num-of-cols)) (cond ((equal 0 (nth jj (nth ii board))) (push (list (list ii jj 'R) nil 'B) list-of-moves))
                                               (t (push (list (list ii jj 'R) nil 'W) list-of-moves)) ) )
            (t nil) ) )
    (cond ((equal ii (1- num-of-rows)) (loop for jj from 0 to (1- num-of-cols) do
                                       (cond ((equal 0 (nth jj (nth ii board))) (push (list (list ii jj 'B) nil 'B) list-of-moves))
                                             (t (push (list (list ii jj 'B) nil 'W) list-of-moves)) ) ))
          (t nil) ) )
  (place-initial-edges) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Return the edge of the adjacent square that gets affected due to current move
(defun get-duplicate-move (rrr ccc eee)
  (cond ((equal ccc 0) (cond ((equal eee 'R) (list rrr (1+ ccc) 'L))
                             ((and (equal rrr 0)
                                   (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                             ((and (equal rrr (1- num-of-rows))
                                   (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                             (t (cond ((and (< rrr (1- num-of-rows))
                                            (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                      ((and (> rrr 0)
                                            (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                      (t nil) )) ))
        ((equal ccc (1- num-of-cols)) (cond ((equal eee 'L) (list rrr (1- ccc) 'R))
                                            ((and (equal rrr 0)
                                                  (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                            ((and (equal rrr (1- num-of-rows))
                                                  (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                            (t (cond ((and (< rrr (1- num-of-rows))
                                                           (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                                     ((and (> rrr 0)
                                                           (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                                     (t nil) )) ))
        (t (cond ((equal eee 'R) (list rrr (1+ ccc) 'L))
                 ((equal eee 'L) (list rrr (1- ccc) 'R))
                 ((and (< rrr (1- num-of-rows))
                       (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                 ((and (> rrr 0)
                       (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                 (t nil) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Increment the counter for a particular square
(defun update-square (rrrr cccc type)
  (cond ((equal type 1) (cond ((numberp (nth cccc (nth rrrr cboard))) (setf (nth cccc (nth rrrr cboard)) (1+ (nth cccc (nth rrrr cboard)))))
                              (t nil) ))
        (t (cond ((numberp (nth cccc (nth rrrr cboard))) (setf (nth cccc (nth rrrr cboard)) (1- (nth cccc (nth rrrr cboard)))))
                 (t nil) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Update the counter-board (cboard) based on the move
(defun update-score (rr cc ee type)
  (update-square rr cc type)
  (setq dmove (get-duplicate-move rr cc ee))
  (cond ((null dmove) nil)
        (t (setq rr (nth 0 dmove))
           (setq cc (nth 1 dmove))
           (update-square rr cc type) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun make-move (d f g)
  (cond ((not (member (list d f g) final-moves-fixed :test #'equal)) (update-score d f g 1))
        (t nil) )
  (push (list d f g) final-moves) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if there is any T shape (crossing or branch)
(defun is-crossing (i j e num-of-rows num-of-cols)
  (cond ((equal e 'T) (cond ((equal j 0) (cond ((equal i 0) (cond ((and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) ) t )
                                                                  (t nil) ))
                                               (t (cond ((or (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) )
                                                             (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'T) final-moves :test #'equal) )
                                                             (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                  (member (list i j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) )) ))
                            ((equal j (1- num-of-cols)) (cond ((equal i 0) (cond ((and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                       (member (list i j 'L) final-moves :test #'equal) ) t )
                                                                                 (t nil) ))
                                                              (t (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list i j 'L) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                                 (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'R) final-moves :test #'equal)
                                                                                 (member (list i j 'R) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                                 (member (list i j 'L) final-moves :test #'equal) ) ) t )
                                                                       (t nil) )) ))
                            (t (cond ((equal i 0) (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list i j 'L) final-moves :test #'equal) )
                                                             (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) ))
                                     (t (cond ((or (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                   (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'T) final-moves :test #'equal) )
                                                   (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                        (member (list i j 'L) final-moves :test #'equal) )
                                                   (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) )
                                                   (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                              (t nil) )) )) ))
        ((equal e 'L) (cond ((equal i 0) (cond ((equal j 0) (cond ((and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) ) t )
                                                                  (t nil) ))
                                               (t (cond ((or (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) j 'L) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'T) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'T) final-moves :test #'equal) )
                                                             (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list i j 'T) final-moves :test #'equal) ) ) t )
                                                        (t nil) )) ))
                            ((equal i (1- num-of-rows)) (cond ((equal j 0) (cond ((and (member (list i j 'T) final-moves :test #'equal)
                                                                                       (member (list (1- i) j 'L) final-moves :test #'equal) ) t )
                                                                                 (t nil) ))
                                                              (t (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                                            (and (member (list i j 'T) final-moves :test #'equal)
                                                                                 (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                                            (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list i j 'T) final-moves :test #'equal) )
                                                                            (and (member (list i (1- j) 'B) final-moves :test #'equal)
                                                                                 (member (list i j 'B) final-moves :test #'equal) ) ) t )
                                                                       (t nil) )) ))
                            (t (cond ((equal j 0) (cond ((or (and (member (list i j 'T) final-moves :test #'equal)
                                                                  (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) ))
                                     (t (cond ((or (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                   (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i j 'T) final-moves :test #'equal) )
                                                   (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                        (member (list i j 'T) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'T) final-moves :test #'equal) ) ) t )
                                              (t nil) )) )) ))
        ((equal e 'R) (cond ((equal i 0) (cond ((and (member (list (1+ i) j 'R) final-moves :test #'equal)
                                                     (member (list i (1+ j) 'T) final-moves :test #'equal) ) t )
                                               (t nil) ))
                            ((equal i (1- num-of-rows)) (cond ((and (member (list i j 'T) final-moves :test #'equal)
                                                                    (member (list (1- i) j 'R) final-moves :test #'equal) ) t )
                                                              (t nil) ))
                            (t (cond ((or (and (member (list (1- i) j 'R) final-moves :test #'equal)
                                               (member (list i j 'T) final-moves :test #'equal) )
                                          (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                               (member (list (1+ i) j 'R) final-moves :test #'equal) ) ) t )
                                     (t nil) )) ))
        (t (cond ((equal j 0) (cond ((and (member (list i (1+ j) 'L) final-moves :test #'equal)
                                          (member (list i (1+ j) 'B) final-moves :test #'equal) ) t )
                                    (t nil) ))
                 ((equal j (1- num-of-cols)) (cond ((or (and (member (list i (1- j) 'B) final-moves :test #'equal)
                                                             (member (list i j 'L) final-moves :test #'equal) )
                                                        (and (member (list i (1+ j) 'L) final-moves :test #'equal)
                                                             (member (list i (1+ j) 'B) final-moves :test #'equal) ) ) t )
                                                   (t nil) ))
                 (t (cond ((or (and (member (list i j 'L) final-moves :test #'equal)
                                    (member (list i (1- j) 'B) final-moves :test #'equal) )
                               (and (member (list i (1+ j) 'L) final-moves :test #'equal)
                                    (member (list i (1+ j) 'B) final-moves :test #'equal) ) ) t )
                          (t nil) )) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Set edge in edge counter
(defun update-edge-count (k edge-type direction)
  (cond ((equal direction 0) (setf (nth k edge-type)
                             (1- (nth k edge-type)) ) )
        (t (setf (nth k edge-type) (1+ (nth k edge-type))) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if loop is closed
(defun is-loop ()
  (setq v (make-list num-of-rows :initial-element 0))
  (setq h (make-list num-of-cols :initial-element 0))
  (loop for amove in final-moves do
    (cond ((or (equal (nth 2 amove) 'L)
               (equal (nth 2 amove) 'R) ) (update-edge-count (nth 0 amove) v 1) )
          (t (update-edge-count (nth 1 amove) h 1)) ) )
    (cond ((or (some #'(lambda (n) (equal (mod n 2) 1)) h)
               (some #'(lambda (n) (equal (mod n 2) 1)) v) ) nil )
          (t t) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Remove marked move from the board
(defun undo-move (move)
  (cond ((not (member move final-moves-fixed :test #'equal)) (update-score (nth 0 move) (nth 1 move) (nth 2 move) 0))
        (t nil) )
  (setf final-moves (delete move final-moves :test #'equal)) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if adding an edge would violate the number of edges that square is supposed to have
(defun counter-mismatch (i j e)
  (cond ((numberp (nth j (nth i board))) (cond ((> (nth j (nth i cboard)) (nth j (nth i board))) t)
                                               (t (setq dupmove (get-duplicate-move i j e)) (cond ((and (not (null dupmove))
                                                                                                        (numberp (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) ) (cond ((> (nth (nth 1 dupmove) (nth (nth 0 dupmove) cboard)) (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) t)
                                                                                                                                                                            (t nil) ))
                                                                                                  (t nil) )) ))
        (t (setq dupmove (get-duplicate-move i j e))
           (cond ((and (not (null dupmove))
                       (numberp (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) ) (cond ((> (nth (nth 1 dupmove) (nth (nth 0 dupmove) cboard)) (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) t)
                                                                                           (t nil) ) )
                 (t nil) ) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun print-row (row r c)
  (cond ((null row) (cond ((member (list r (1- c) 'R) final-moves :test #'equal) (princ "|"))
                          (t (princ " ")) ))
        (t (cond ((member (list r c 'L) final-moves :test #'equal) (princ "|"))
                 ((member (list r (1- c) 'R) final-moves :test #'equal) (princ "|"))
                 (t (princ " ")) )
           (cond ((equal '- (car row)) (princ " "))
                 (t (princ (car row))) )
           (print-row (cdr row) r (1+ c)) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun print-board (pboard num-of-rows num-of-cols mypos)
  (cond ((null pboard) (princ "  +")
                       (setq l 0)
                       (loop
                         (cond ((member (list (1- num-of-rows) l 'B) final-moves :test #'equal) (princ "-")
                                                                                                (princ "+"))
                               (t (princ " ")
                                  (princ "+")) )
                         (setq l (1+ l))
                         (when (equal l num-of-cols)
                           (terpri)
                           (return t) ) ) )
        (t (princ "  +")
           (setq l 0)
           (loop
             (cond ((member (list mypos l 'T) final-moves :test #'equal) (princ "-")
                                                                         (princ "+"))
                   ((member (list (1- mypos) l 'B) final-moves :test #'equal) (princ "-")
                                                                              (princ "+"))
                   (t (princ " ")
                      (princ "+")) )
             (setq l (1+ l))
             (when (equal l num-of-cols)
               (terpri)
               (return t) ) )
           (princ (1+ mypos))
           (princ " ")
           (print-row (car pboard) mypos 0)
           (terpri)
           (print-board (cdr pboard) num-of-rows num-of-cols (1+ mypos))
           (terpri) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun add-neighbor (nbr move)
  (cond ((equal 'W (nth 2 (find nbr list-of-moves :key #'car :test #'equal))) (push (position nbr list-of-moves :key #'car :test #'equal) (nth 1 move)))
        (t nil) ) )


;;------------------------------------------------------------------------------------------------------------------------------

;;;depth first search for the solution
(defun dfs (move list-of-moves pboard)
  (setq i (nth 0 (car move)))
  (setq j (nth 1 (car move)))
  (setq e (nth 2 (car move)))
  (setf (nth 2 (find move list-of-moves :test #'equal)) 'G)
  (cond ((not (member (car move) final-moves :test #'equal)) (make-move i j e))
        (t nil) )
  (cond ((or (counter-mismatch i j e)
             (is-crossing i j e num-of-rows num-of-cols) ) (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                                                           (undo-move (list i j e))
                                                           (return-from dfs 0) )
        ((is-loop) (cond ((equal cboard board) (return-from dfs 1))
                         (t (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                            (undo-move (list i j e))
                            (return-from dfs 0) ) ))
        (t (cond ((equal e 'T) (add-neighbor (list i j 'L) move)
                               (cond ((< j (1- num-of-cols)) (add-neighbor (list i (1+ j) 'T) move)
                                                             (add-neighbor (list i (1+ j) 'L) move)
                                                             (cond ((> i 0) (add-neighbor (list (1- i) (1+ j) 'L) move))
                                                                   (t nil) ) )
                                     (t nil) )
                               (cond ((> j 0) (add-neighbor (list i (1- j) 'T) move))
                                     (t nil) )
                               (cond ((> i 0) (add-neighbor (list (1- i) j 'L) move))
                                     (t nil) )
                               (cond ((equal j (1- num-of-cols)) (cond ((> i 0) (add-neighbor (list (1- i) j 'R) move))
                                                                       (t nil) )
                                                                 (add-neighbor (list i j 'R) move) )
                                     (t nil) ) )
                 ((equal e 'L) (add-neighbor (list i j 'T) move)
                               (cond ((< i (1- num-of-cols)) (add-neighbor (list (1+ i) j 'T) move)
                                                             (add-neighbor (list (1+ i) j 'L) move)
                                                             (cond ((> j 0) (add-neighbor (list (1+ i) (1- j) 'T) move))
                                                                   (t nil) ) )
                                     (t nil) )
                               (cond ((> j 0) (add-neighbor (list i (1- j) 'T) move))
                                     (t nil) )
                               (cond ((> i 0) (add-neighbor (list (1- i) j 'L) move))
                                     (t nil) )
                               (cond ((equal i (1- num-of-rows)) (add-neighbor (list i j 'B) move)
                                                                 (cond ((> j 0) (add-neighbor (list i (1- j) 'B) move))
                                                                       (t nil) ))
                                     (t nil) ) )
                 ((equal e 'R) (add-neighbor (list i j 'T) move)
                               (cond ((< i (1- num-of-rows)) (add-neighbor (list (1+ i) j 'R) move)
                                                             (add-neighbor (list (1+ i) j 'T) move) )
                                     (t nil) )
                               (cond ((> i 0) (add-neighbor (list (1- i) j 'R) move))
                                     (t nil) )
                               (cond ((equal i (1- num-of-rows)) (add-neighbor (list i j 'B) move))
                                     (t nil) ) )
                 (t (add-neighbor (list i j 'L) move)
                    (cond ((< j (1- num-of-cols)) (add-neighbor (list i (1+ j) 'B) move)
                                                  (add-neighbor (list i (1+ j) 'L) move) )
                          (t nil) )
                    (cond ((> j 0) (add-neighbor (list i (1- j) 'B) move))
                          (t nil) )
                    (cond ((equal j (1- num-of-cols)) (add-neighbor (list i j 'R) move))
                          (t nil) ) ) )
            (setq final-nbr-chkr 0)
            (loop for neighbor in (nth 1 move) do
              (cond ((and (member (car (nth neighbor list-of-moves)) final-moves-fixed :test #'equal)
                          (equal 'W (nth 2 (nth neighbor list-of-moves))) ) (setq final-nbr-chkr 1)
                                                                            (setq result (dfs (nth neighbor list-of-moves) list-of-moves pboard))
                                                                            (cond ((equal 1 result) (return-from dfs 1))
                                                                                  (t (setf (nth 1 (find move list-of-moves :test #'equal)) nil)
                                                                                     (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                                                                                     (undo-move (car move))
                                                                                     (return-from dfs 0) ) ) )
                    (t nil) ) )
            (cond ((equal final-nbr-chkr 1) (setf (nth 1 (find move list-of-moves :test #'equal)) nil)
                                            (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                                            (undo-move (car move))
                                            (return-from dfs 0) )
                  (t (loop for neighbor in (nth 1 move) do
                       (cond ((equal 'W (nth 2 (nth neighbor list-of-moves))) (setq result (dfs (nth neighbor list-of-moves) list-of-moves pboard))
                                                                              (cond ((equal 1 result) (return-from dfs 1))
                                                                                    (t (setf (nth 1 move) (remove neighbor (nth 1 move)))) ) )
                             (t (setf (nth 1 move) (remove neighbor (nth 1 move)))) ) )
                     (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                     (undo-move (car move))
                     (return-from dfs 0) ) ) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;main routine
(defun slitherauto ()
  (princ "Enter full path to the file containing description of the board:")
  (setq infile (read-line))
  (terpri)
  (create-board infile)
  (princ "Initial board: ")
  (terpri)
  (princ "   ")
  (loop for i from 1 to num-of-cols do ;print column numbers
    (princ i)
    (princ " ") )
  (terpri)
  (print-board pboard num-of-rows num-of-cols 0)
  (initialize-for-dfs)
  (cond ((null final-moves-fixed) (princ "Find the first 3 and start DFS from any of its edges")
                                  (terpri)
                                  (princ "If there is no 3, find the first 2 and do the same")
                                  (terpri)
                                  (princ "If there is no 2, find the first 1 and do the same")
                                  (terpri) )
        (t (setq imove (find (car final-moves-fixed) list-of-moves :key #'car :test #'equal))
		   (princ "Time taken:")
		   (terpri)
           (time (dfs imove list-of-moves pboard))
		   (terpri)
		   (terpri)
           (princ "Final board: ")
           (terpri)
		   (princ "   ")
           (loop for i from 1 to num-of-cols do ;print column numbers
           (princ i)
           (princ " ") )
           (terpri)
		   (print-board pboard num-of-rows num-of-cols 0)
           (princ "Following is the list of moves made to get the solution: ")
           (terpri)
           (loop for fmove in final-moves do
             (princ (mapcar (lambda (x) (cond ((equal T x) x) ((symbolp x) x) ((constantp x) (1+ x)))) fmove))
             (terpri) ) ) ) )