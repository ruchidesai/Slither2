;;;Accept the file containing the board description from the user and initialize counter boards
(defun create-board (filename)
  (let ((infile (open filename)))
    (setq board (read infile))
    (setq pboard board)
    (setq cboard (mapcar (lambda (xx) (cond ((listp xx) (mapcar (lambda (yy) (cond ((constantp yy) 0)
                                                                                   (t yy) )) xx ))
                                            (t nil) )) board ))
    (close infile) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Initialize the lists of moves
(defun initialize-for-dfs ()
  (setq list-of-moves nil)
  (setq final-moves nil)
  (setq num-of-rows (list-length board))
  (setq num-of-cols (list-length (car board)))
  (loop for ii from 0 to (1- num-of-rows) do
    (loop for jj from 0 to (1- num-of-cols) do
      (cond ((> ii 0) (cond ((equal 0 (nth jj (nth (1- ii) board))) (push (list (list ii jj 'T) nil 'B) list-of-moves))
                            (t nil) ))
            (t nil) )
      (cond ((> jj 0) (cond ((equal 0 (nth (1- jj) (nth ii board))) (push (list (list ii jj 'L) nil 'B) list-of-moves))
                            (t nil) ))
            (t nil) )
      (cond ((equal 0 (nth jj (nth ii board))) (push (list (list ii jj 'L) nil 'B) list-of-moves)
                                               (push (list (list ii jj 'T) nil 'B) list-of-moves) )
            (t (push (list (list ii jj 'L) nil 'W) list-of-moves)
               (push (list (list ii jj 'T) nil 'W) list-of-moves) ) )
      (cond ((equal jj (1- num-of-cols)) (cond ((equal 0 (nth jj (nth ii board))) (push (list (list ii jj 'R) nil 'B) list-of-moves))
                                               (t (push (list (list ii jj 'R) nil 'W) list-of-moves)) ) )
            (t nil) ) )
    (cond ((equal ii (1- num-of-rows)) (loop for jj from 0 to (1- num-of-cols) do
                                       (cond ((equal 0 (nth jj (nth ii board))) (push (list (list ii jj 'B) nil 'B) list-of-moves))
                                             (t (push (list (list ii jj 'B) nil 'W) list-of-moves)) ) ))
          (t nil) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Return the edge of the adjacent square that gets affected due to current move
(defun get-duplicate-move (rrr ccc eee)
  (cond ((equal ccc 0) (cond ((equal eee 'R) (list rrr (1+ ccc) 'L))
                             ((and (equal rrr 0)
                                   (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                             ((and (equal rrr (1- num-of-rows))
                                   (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                             (t (cond ((and (< rrr (1- num-of-rows))
                                            (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                      ((and (> rrr 0)
                                            (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                      (t nil) )) ))
        ((equal ccc (1- num-of-cols)) (cond ((equal eee 'L) (list rrr (1- ccc) 'R))
                                            ((and (equal rrr 0)
                                                  (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                            ((and (equal rrr (1- num-of-rows))
                                                  (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                            (t (cond ((and (< rrr (1- num-of-rows))
                                                           (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                                                     ((and (> rrr 0)
                                                           (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                                                     (t nil) )) ))
        (t (cond ((equal eee 'R) (list rrr (1+ ccc) 'L))
                 ((equal eee 'L) (list rrr (1- ccc) 'R))
                 ((and (< rrr (1- num-of-rows))
                       (equal eee 'B) ) (list (1+ rrr) ccc 'T) )
                 ((and (> rrr 0)
                       (equal eee 'T) ) (list (1- rrr) ccc 'B) )
                 (t nil) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Increment the counter for a particular square
(defun update-square (rrrr cccc type)
  (cond ((equal type 1) (cond ((numberp (nth cccc (nth rrrr cboard))) (setf (nth cccc (nth rrrr cboard)) (1+ (nth cccc (nth rrrr cboard)))))
                              (t nil) ))
        (t (cond ((numberp (nth cccc (nth rrrr cboard))) (setf (nth cccc (nth rrrr cboard)) (1- (nth cccc (nth rrrr cboard)))))
                 (t nil) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Update the counter-board (cboard) based on the move
(defun update-score (rr cc ee type)
  (update-square rr cc type)
  (setq dmove (get-duplicate-move rr cc ee))
  (cond ((null dmove) nil)
        (t (setq rr (nth 0 dmove))
           (setq cc (nth 1 dmove))
           (update-square rr cc type)) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun make-move (d f g)
  (update-score d f g 1)
  (push (list d f g) final-moves) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if there is any T shape (crossing or branch)
(defun is-crossing (i j e num-of-rows num-of-cols)
  (cond ((equal e 'T) (cond ((equal j 0) (cond ((equal i 0) (cond ((and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) ) t )
                                                                  (t nil) ))
                                               (t (cond ((or (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) )
                                                             (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'T) final-moves :test #'equal) )
                                                             (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                  (member (list i j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) )) ))
                            ((equal j (1- num-of-cols)) (cond ((equal i 0) (cond ((and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                       (member (list i (1- j) 'L) final-moves :test #'equal) ) t )
                                                                                 (t nil) ))
                                                              (t (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list i j 'L) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                                 (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'R) final-moves :test #'equal)
                                                                                 (member (list i j 'R) final-moves :test #'equal) )
                                                                            (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                                                 (member (list i j 'L) final-moves :test #'equal) ) ) t )
                                                                       (t nil) )) ))
                            (t (cond ((equal i 0) (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list i j 'L) final-moves :test #'equal) )
                                                             (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                                  (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) ))
                                     (t (cond ((or (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                   (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'T) final-moves :test #'equal) )
                                                   (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                        (member (list i j 'L) final-moves :test #'equal) )
                                                   (and (member (list i (1+ j) 'T) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) )
                                                   (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1- i) (1+ j) 'L) final-moves :test #'equal)
                                                        (member (list i (1+ j) 'L) final-moves :test #'equal) ) ) t )
                                              (t nil) )) )) ))
        ((equal e 'L) (cond ((equal i 0) (cond ((equal j 0) (cond ((and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) ) t )
                                                                  (t nil) ))
                                               (t (cond ((or (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) j 'L) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'T) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'T) final-moves :test #'equal) )
                                                             (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                  (member (list i j 'T) final-moves :test #'equal) ) ) t )
                                                        (t nil) )) ))
                            ((equal i (1- num-of-rows)) (cond ((equal j 0) (cond ((and (member (list i j 'T) final-moves :test #'equal)
                                                                                       (member (list (1- i) j 'L) final-moves :test #'equal) ) t )
                                                                                 (t nil) ))
                                                              (t (cond ((or (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                                            (and (member (list i j 'T) final-moves :test #'equal)
                                                                                 (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                                            (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                                                 (member (list i j 'T) final-moves :test #'equal) )
                                                                            (and (member (list i (1- j) 'B) final-moves :test #'equal)
                                                                                 (member (list i j 'B) final-moves :test #'equal) ) ) t )
                                                                       (t nil) )) ))
                            (t (cond ((equal j 0) (cond ((or (and (member (list i j 'T) final-moves :test #'equal)
                                                                  (member (list (1- i) j 'L) final-moves :test #'equal) )
                                                             (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                                  (member (list (1+ i) j 'L) final-moves :test #'equal) ) ) t )
                                                        (t nil) ))
                                     (t (cond ((or (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i (1- j) 'T) final-moves :test #'equal) )
                                                   (and (member (list (1- i) j 'L) final-moves :test #'equal)
                                                        (member (list i j 'T) final-moves :test #'equal) )
                                                   (and (member (list i (1- j) 'T) final-moves :test #'equal)
                                                        (member (list i j 'T) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'L) final-moves :test #'equal) )
                                                   (and (member (list (1+ i) (1- j) 'T) final-moves :test #'equal)
                                                        (member (list (1+ i) j 'T) final-moves :test #'equal) ) ) t )
                                              (t nil) )) )) ))
        ((equal e 'R) (cond ((equal i 0) (cond ((and (member (list (1+ i) j 'R) final-moves :test #'equal)
                                                     (member (list i (1+ j) 'T) final-moves :test #'equal) ) t )
                                               (t nil) ))
                            (t (cond ((or (and (member (list (1- i) j 'R) final-moves :test #'equal)
                                               (member (list i j 'T) final-moves :test #'equal) )
                                          (and (member (list (1+ i) j 'T) final-moves :test #'equal)
                                               (member (list (1+ i) j 'R) final-moves :test #'equal) ) ) t )
                                     (t nil) )) ))
        (t (cond ((equal j 0) (cond ((and (member (list i (1+ j) 'L) final-moves :test #'equal)
                                          (member (list i (1+ j) 'B) final-moves :test #'equal) ) t )
                                    (t nil) ))
                 ((equal j (1- num-of-cols)) (cond ((or (and (member (list i (1- j) 'B) final-moves :test #'equal)
                                                             (member (list i j 'L) final-moves :test #'equal) )
                                                        (and (member (list i (1+ j) 'L) final-moves :test #'equal)
                                                             (member (list i (1+ j) 'B) final-moves :test #'equal) ) ) t )
                                                   (t nil) )) )) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Set edge in edge counter
(defun update-edge-count (k edge-type direction)
  (cond ((equal direction 0) (setf (nth k edge-type)
                             (1- (nth k edge-type)) ) )
        (t (setf (nth k edge-type) (1+ (nth k edge-type))) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if loop is closed
(defun is-loop ()
  (setq v (make-list num-of-rows :initial-element 0))
  (setq h (make-list num-of-cols :initial-element 0))
  (loop for amove in final-moves do
    (cond ((or (equal (nth 2 amove) 'L)
               (equal (nth 2 amove) 'R) ) (update-edge-count (nth 0 amove) v 1) )
          (t (update-edge-count (nth 1 amove) h 1)) ) )
    (cond ((or (some #'(lambda (n) (equal (mod n 2) 1)) h)
               (some #'(lambda (n) (equal (mod n 2) 1)) v) ) nil )
          (t t) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Remove marked move from the board
(defun undo-move (move)
  (update-score (nth 0 move) (nth 1 move) (nth 2 move) 0)
  (setf final-moves (delete move final-moves :test #'equal)) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;Check if adding an edge would violate the number of edges that square is supposed to have
(defun counter-mismatch (i j e)
  (cond ((numberp (nth j (nth i board))) (cond ((> (nth j (nth i cboard)) (nth j (nth i board))) t)
                                               (t (setq dupmove (get-duplicate-move i j e)) (cond ((and (not (null dupmove))
											                                                            (numberp (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) ) (cond ((> (nth (nth 1 dupmove) (nth (nth 0 dupmove) cboard)) (nth (nth 1 dupmove) (nth (nth 0 dupmove) board))) t)
                                                                                                                                                                            (t nil) ))
                                                                                                  (t nil) )) ))
        (t nil) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun print-row (row r c)
  (cond ((null row) (cond ((member (list r (1- c) 'R) final-moves :test #'equal) (princ "|"))
                          (t (princ " ")) ))
        (t (cond ((member (list r c 'L) final-moves :test #'equal) (princ "|"))
                 ((member (list r (1- c) 'R) final-moves :test #'equal) (princ "|"))
                 (t (princ " ")) )
           (cond ((equal '- (car row)) (princ " "))
                 (t (princ (car row))) )
           (print-row (cdr row) r (1+ c)) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

(defun print-board (pboard num-of-rows num-of-cols mypos)
  (cond ((null pboard) (princ "  +")
                       (setq l 0)
                       (loop
                         (cond ((member (list (1- num-of-rows) l 'B) final-moves :test #'equal) (princ "-")
                                                                                                  (princ "+"))
                               (t (princ " ")
                                  (princ "+")) )
                         (setq l (1+ l))
                         (when (equal l num-of-cols)
                           (terpri)
                           (return t) ) ) )
        (t (princ "  +")
           (setq l 0)
           (loop
             (cond ((member (list mypos l 'T) final-moves :test #'equal) (princ "-")
                                                                           (princ "+"))
                   ((member (list (1- mypos) l 'B) final-moves :test #'equal) (princ "-")
                                                                                (princ "+"))
                   (t (princ " ")
                      (princ "+")) )
             (setq l (1+ l))
             (when (equal l num-of-cols)
               (terpri)
               (return t) ) )
           (princ (1+ mypos))
           (princ " ")
           (print-row (car pboard) mypos 0)
           (terpri)
           (print-board (cdr pboard) num-of-rows num-of-cols (1+ mypos))
           (terpri) ) ) )

;;------------------------------------------------------------------------------------------------------------------------------

;;;depth first search
(defun dfs (move list-of-moves pboard)
  (setq i (nth 0 (car move)))
  (setq j (nth 1 (car move)))
  (setq e (nth 2 (car move)))
  (setf (nth 2 (find move list-of-moves :test #'equal)) 'G)
  (make-move i j e)
  ;;(read)
  ;;(print-board pboard num-of-rows num-of-cols 0)
  (cond ((or (counter-mismatch i j e)
             (is-crossing i j e num-of-rows num-of-cols) ) (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                                                     (undo-move (list i j e))
                                                     (return-from dfs 0) )
        ((is-loop) (cond ((equal cboard board) (return-from dfs 1))
                         (t (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
                            (undo-move (list i j e))
                            (return-from dfs 0) ) ))
        (t (cond ((equal e 'T) (push (position (list i j 'L) list-of-moves :key #'car :test #'equal) (nth 1 move))
                               (cond ((< j (1- num-of-cols)) (push (position (list i (1+ j) 'T) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                             (push (position (list i (1+ j) 'L) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                             (cond ((> i 0) (push (position (list (1- i) (1+ j) 'L) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                                                   (t nil) ) )
                                     (t nil) )
                               (cond ((> j 0) (push (position (list i (1- j) 'T) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) )
                               (cond ((> i 0) (push (position (list (1- i) j 'L) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) )
                               (cond ((equal j (1- num-of-cols)) (cond ((> i 0) (push (position (list (1- i) j 'R) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                                                       (t nil) )
                                                                 (push (position (list i j 'R) list-of-moves :key #'car :test #'equal) (nth 1 move)) )
                                     (t nil) ) )
                 ((equal e 'L) (push (position (list i j 'T) list-of-moves :key #'car :test #'equal) (nth 1 move))
                               (cond ((< i (1- num-of-cols)) (push (position (list (1+ i) j 'T) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                             (push (position (list (1+ i) j 'L) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                             (cond ((> j 0) (push (position (list (1+ i) (1- j) 'T) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                                                   (t nil) ) )
                                     (t nil) )
                               (cond ((> j 0) (push (position (list i (1- j) 'T) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) )
                               (cond ((> i 0) (push (position (list (1- i) j 'L) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) )
                               (cond ((equal i (1- num-of-rows)) (push (position (list i j 'B) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                                 (cond ((> j 0) (push (position (list i (1- j) 'B) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                                                       (t nil) ))
                                     (t nil) ) )
                 ((equal e 'R) (push (position (list i j 'T) list-of-moves :key #'car :test #'equal) (nth 1 move))
                               (cond ((< i (1- num-of-rows)) (push (position (list (1+ i) j 'R) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                             (push (position (list (1+ i) j 'T) list-of-moves :key #'car :test #'equal) (nth 1 move)) )
                                     (t nil) )
                               (cond ((> i 0) (push (position (list (1- i) j 'R) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) )
                               (cond ((equal i (1- num-of-rows)) (push (position (list i j 'B) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                                     (t nil) ) )
                 (t (push (position (list i j 'L) list-of-moves :key #'car :test #'equal) (nth 1 move))
                    (cond ((< j (1- num-of-cols)) (push (position (list i (1+ j) 'B) list-of-moves :key #'car :test #'equal) (nth 1 move))
                                                  (push (position (list i (1+ j) 'L) list-of-moves :key #'car :test #'equal) (nth 1 move)) )
                          (t nil) )
                    (cond ((> j 0) (push (position (list i (1- j) 'B) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                          (t nil) )
                    (cond ((equal j (1- num-of-cols)) (push (position (list i j 'R) list-of-moves :key #'car :test #'equal) (nth 1 move)))
                          (t nil) ) ) )
            (loop for neighbor in (nth 1 move) do
              (cond ((equal 'W (nth 2 (nth neighbor list-of-moves))) (setq result (dfs (nth neighbor list-of-moves) list-of-moves pboard))
                                                                     (cond ((equal 1 result) (return-from dfs 1))
                                                                           (t (setf (nth 1 move) (remove neighbor (nth 1 move)))) ) )
                    (t (setf (nth 1 move) (remove neighbor (nth 1 move)))) ) ) ) )
  (setf (nth 2 (find move list-of-moves :test #'equal)) 'W)
  (undo-move (car move))
  (return-from dfs 0) )